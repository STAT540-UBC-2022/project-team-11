---
output: github_document
editor_options: 
  chunk_output_type: inline
---

# Load packages

```{r message=FALSE,warning=FALSE}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(GEOquery))
suppressPackageStartupMessages(library(limma))
suppressPackageStartupMessages(library(edgeR))
suppressPackageStartupMessages(library(pheatmap))
suppressPackageStartupMessages(library(statmod))
suppressPackageStartupMessages(library(ggrepel))
suppressPackageStartupMessages(library(ggbiplot))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(GGally))
suppressPackageStartupMessages(library(caTools)) ## used for splitting the data into training and validation sets
suppressPackageStartupMessages(library(caret)) ## used for confusion matrix, accuracy, sensitivity, and specificity
suppressPackageStartupMessages(library(mice))
suppressPackageStartupMessages(library(VIM))
suppressPackageStartupMessages(library(sva))
suppressPackageStartupMessages(library(missForest))
suppressPackageStartupMessages(library(RANN))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(goseq))
suppressPackageStartupMessages(library(GOplot))
suppressPackageStartupMessages(library(clusterProfiler))
suppressPackageStartupMessages(library(org.Hs.eg.db))
suppressPackageStartupMessages(library(viridis))
```


```{r}
## Setting work directory to save plots 
setwd(getwd())
```

```{r, warning=FALSE, message=FALSE, results='hide'}
eset <- getGEO("GSE152075", getGPL = FALSE)[[1]]
getGEOSuppFiles("GSE152075")

#Read in the count matrix
raw_counts <- read.csv("GSE152075/GSE152075_raw_counts_GEO.txt", sep = "")
count_mat <- as.matrix(raw_counts,row.names="gene_id")
```

```{r}
#Read in the metadata
pdata <- eset@phenoData@data %>% as_tibble()

#Subset the metadata to include only columns of interest
pdata_clean = pdata %>%
  dplyr::select(title, `age:ch1`, `gender:ch1`, `sequencing_batch:ch1`, `sars-cov-2 positivity:ch1`, `n1_ct:ch1`)

#Rename metadata columns
colnames(pdata_clean) = c("Sample", "Age", "Gender", "Batch", "Sars_test", "Viral_load")

pdata_clean <- within(pdata_clean, Age[Age == "90+"] <- "90")

#Modify the subset data to create a new column of Age_categories based on the column Age 
pdata_mod <- pdata_clean %>%
  transform(Age = as.numeric(Age))

pdata_mod = pdata_mod %>%
  mutate(Age_category =  case_when(
    Age < 18 ~ "Child",
    Age >= 18 & Age < 35 ~ "Young Adult",
    Age >= 35 & Age < 65  ~ "Adult",
    Age >= 65 ~ "Senior"
  )) 

#Exclude samples where the newly created column has NAs for Age categories
pdata_mod <- pdata_mod[complete.cases(pdata_mod), ]

#Convert all character variables of interest to factor type 
convert = c("Age_category", "Gender", "Sars_test", "Batch")
pdata_mod[convert] <- lapply(pdata_mod[convert], factor)
```

```{r}
#Examine metadata
table(pdata_mod$Gender)
pdata_mod %>% 
  dplyr::select(-Sample, -Viral_load, -Age) %>%
  ggpairs(aes(color=Sars_test, alpha=0.4), cardinality_threshold = 100)
```

```{r}
# Extracting info about samples with unknown age
data = pdata %>%
       dplyr::select(title, `age:ch1`) %>% 
       subset(`age:ch1` == "Unknown")

drop <- data$title

#Removing samples that have unknown age from the count matrix
count_mat_final  = count_mat[,!colnames(count_mat) %in% drop]
```

```{r}
# Convert raw counts data matrix to data frame
count_mat_mod <- count_mat %>% 
  as.data.frame() %>% 
  rownames_to_column("gene_id")

# Transform counts data to a long form for merging with metadata
count_mat_mod <- count_mat_mod %>% 
  pivot_longer(-gene_id, names_to = "Sample", values_to = "Expression")

# Join raw counts to filtered metadata. This automatically drops samples in the counts data that are not in the filtered metadata
counts_pdata <- pdata_mod %>% 
  left_join(count_mat_mod, by = "Sample")

# Transform data back to a wide format
counts_pdata <- pivot_wider(counts_pdata,
                             names_from = gene_id, 
                             values_from = Expression) %>% 
                column_to_rownames("Sample")

#Modify data to convert all "Unknown" values to NAs within the Gender column to feed into the imputation function
data = counts_pdata
data$Viral_load[data$Viral_load == "N/A"] <- 0
data$Viral_load = as.numeric(data$Viral_load)
levels(data$Gender)[3] <- NA

```

# Imputation with MissForest

```{r}
#Data Imputation
pdata.imp.1 <- missForest(data)
table(pdata.imp.1$ximp$Gender)
pdata.imp.1$OOBerror

#Extract imputed metadata
pdata_imputed = as.data.frame(pdata.imp.1$ximp[,1:6])
pdata_imputed <- tibble::rownames_to_column(pdata_imputed, "Sample")
```


```{r}
#check our two dfs are in the same order
identical(pdata_imputed$Sample, colnames(count_mat_final))
```

```{r}
cov_test <- cbind(c(pdata_mod$Sars_test))

Batches = as.character(pdata_mod$Batch)


dim(count_mat_final)
length(Batches)

corrected_data1 <- ComBat_seq(counts = count_mat_final, batch = Batches, group = cov_test )

dim(count_mat_final)
dim(corrected_data1)
dim(pdata_imputed)
```

```{r}
#Creating DGE List 
dge <- DGEList(counts = corrected_data1, samples = pdata_imputed)
dim(dge)
head(apply(dge$counts, 2, sum)) # total gene counts per sample

#removing lowly expressed genes
keep_edge <- rowSums(cpm(dge)>10) >= 2
dge_mod <- dge[keep_edge,]
dim(dge_mod)
```


```{r, results='hide'}
# Reset library sizes
dge_mod$samples$lib.size <- colSums(dge_mod$counts) 
```

```{r}
#Calculating TMM normalization factors and directly adding them to the DGEList
dge_norm = calcNormFactors(dge_mod, method = "TMM")

#cpm and log transformation after adding a pseudo-count
cpm = cpm(dge_norm, log = FALSE, normalized.lib.sizes = TRUE)
log2cpm = log2(cpm + 1)
```

```{r}
#Randomly sample positive and negative samples to plot a heatmap, density plots and box plot to view the trends within the dataset.
ran_samp = pdata_mod %>%
           group_by(Sars_test) %>%
           sample_n(size = 10)
samples = ran_samp$Sample
names.use <- colnames(log2cpm)[(colnames(log2cpm) %in% samples)]
subset_data <- log2cpm[, names.use]

#Convert the subset data to long format for ease in plotting
longExpr = subset_data %>% 
           as.data.frame() %>% 
           rownames_to_column("gene") %>%
           pivot_longer(cols = !gene,
                        values_to = "Expression",
                        names_to = "Sample")
longExpr <- left_join(longExpr, ran_samp, by="Sample")

#Box plot
longExpr %>%
  ggplot(aes(Sample, Expression)) + 
    geom_boxplot() + 
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

cormat = round(cor(subset_data), 2)

#Density plot
ggplot(data = longExpr) + 
  geom_density(aes(Expression, group=Sample, group="Sars_test"), color="grey") + 
  geom_density(aes(Expression), color="black", size=1.5)

#Create annotation column for pheatmap
annotation_column = data.frame(Infection_state = ran_samp$Sars_test,
                               Age = ran_samp$Age_category,
                               row.names = colnames(cormat))
#Plot heatmap
pheatmap(cormat, border_color = NA, annotation_col = annotation_column, cluster_rows = TRUE, cellheight=9, cellwidth = 9)
```

```{r}
#Setting up model matrix
designMatrix1 = model.matrix(~Sars_test*Gender, data = pdata_imputed)
colnames(designMatrix1)
designMatrix2 = model.matrix(~Sars_test*Age_category, data = pdata_imputed)
colnames(designMatrix2)
designMatrix3 = model.matrix(~Age_category*Gender, data = pdata_imputed)
colnames(designMatrix3)
designMatrix3<- designMatrix3[, -6]
```

```{r}
#Estimating dispersion parameters for each tag
dge_disp1 <- estimateDisp(dge_norm, designMatrix1, robust = TRUE) 
range(dge_disp1$prior.df)
plotBCV(dge_disp1,  cex=0.5)

lfit1 <- glmFit(dge_disp1, designMatrix1)
lrt1 <- glmLRT(lfit1)

#Filtering for up and downregulated genes
deg_1 <- topTags(lrt1, n = Inf, sort.by = "logFC", p.value = 0.05)$table
up_1 <- deg_1[deg_1$logFC > 0,]
nrow(up_1)
down_1 <- deg_1[deg_1$logFC < 0,]
nrow(down_1)

```

```{r}
#Comparing DE genes within samples between positive and negative samples in males and females
up1 = tibble::rownames_to_column(up_1, "Gene")
down1 = tibble::rownames_to_column(down_1, "Gene")
up1 = subset(up1, select = c(1, 5))
down1 = subset(down1, select = c(1, 5))
deg1 = rbind(up1,down1)
norm_deg1 = subset(dge_norm$counts, rownames(dge_norm) %in% deg1$Gene)
longExpr = norm_deg1 %>% 
           as.data.frame() %>% 
           rownames_to_column("Gene") %>%
           pivot_longer(cols = !Gene,
                        values_to = "Expression",
                        names_to = "Sample")
longExpr = left_join(longExpr, dge_norm$samples, by="Sample")
longExpr = left_join(deg1, longExpr, by = "Gene")



#Box plot
p = ggplot(longExpr, aes(x=Gender, y=Expression, fill=Sars_test)) + 
    geom_boxplot() + facet_wrap(. ~ Gene) + scale_y_log10() + theme_bw() + scale_fill_discrete(name = "Test result") + labs(y = "Log10 Expression values", x = "Gender") 

p 
```

```{r}
#Estimating dispersion parameters for each tag
dge_disp2 <- estimateDisp(dge_norm, designMatrix2, robust = TRUE) 
range(dge_disp1$prior.df)
plotBCV(dge_disp1,  cex=0.5)

lfit2 <- glmFit(dge_disp2, designMatrix2)
lrt2 <- glmLRT(lfit2)

#Filtering for up and downregulated genes
deg_2 <- topTags(lrt2, n = Inf, sort.by = "logFC", p.value = 0.05)$table
up_2 <- deg_2[deg_2$logFC > 0,]
nrow(up_2)
down_2 <- deg_2[deg_2$logFC < 0,]
nrow(down_2)
```

```{r}
#Comparing DE genes within samples between positive and negative samples in all age groups
up2 = tibble::rownames_to_column(up_2, "Gene")
down2 = tibble::rownames_to_column(down_2, "Gene")
up2 = subset(up2, select = c(1, 5))
down2 = subset(down2, select = c(1, 5))
deg2 = rbind(up2,down2)
norm_deg2 = subset(dge_norm$counts, rownames(dge_norm) %in% deg2$Gene)
longExpr = norm_deg2 %>% 
           as.data.frame() %>% 
           rownames_to_column("Gene") %>%
           pivot_longer(cols = !Gene,
                        values_to = "Expression",
                        names_to = "Sample")
longExpr = left_join(longExpr, dge_norm$samples, by="Sample")
longExpr = left_join(deg2, longExpr, by = "Gene")

#Box plot
p = longExpr %>%
  mutate(Age_category=factor(Age_category, levels= c("Child", "Young Adult", "Adult", "Senior")))%>% ggplot(aes(x=Age_category, y=Expression, fill=Sars_test)) + 
    geom_boxplot() + scale_y_log10() + theme_bw() + scale_fill_discrete(name = "Test result") + labs(y = "Log10 Expression values", x = "Gender") 
p

#Scatter plot
p = longExpr %>%
  mutate(Age_category=factor(Age_category, levels= c("Child", "Young Adult", "Adult", "Senior")))%>%
  ggplot(aes(x=Age_category, y=Expression, colour = PValue)) + 
    geom_boxplot() + scale_y_log10() + labs(y = "Log10 Expression values", x = "Age categories")
p + scale_color_gradient(low="darkblue", high="red") + geom_point(alpha = 0.05, position=position_jitter(height=0.50, width=0.20)) + facet_wrap(~Sars_test, labeller = label_both) + theme_bw()
```

```{r}
#Estimating dispersion parameters for each tag
dge_disp3 <- estimateDisp(dge_norm, designMatrix3, robust = TRUE) 
range(dge_disp3$prior.df)
plotBCV(dge_disp3,  cex=0.5)

lfit3 <- glmFit(dge_disp3, designMatrix3)
lrt3 <- glmLRT(lfit3)

#Filtering for up and downregulated genes
deg_3 <- topTags(lrt3, n = Inf, p.value = 0.05, sort.by = "logFC")$table
up_3 <- deg_3[deg_3$logFC > 0,]
nrow(up_3)
down_3 <- deg_3[deg_3$logFC < 0,]
nrow(down_3)
```

```{r}
#Matrix with Sars_test and Gender interaction terms
de1 <- decideTestsDGE(lrt1, adjust.method="BH", p.value = 0.05)
de1tags <- rownames(dge_disp1)[as.logical(de1)]
#plotSmear(lrt1, de.tags=de1tags)
plotMD(lrt1, main="MD plot")
abline(h=c(-1, 1), col="blue")
de1_summary <- summary(de1)
de1_summary

#Matrix with Sars_test and age_category interaction terms
de2 <- decideTestsDGE(lrt2, adjust.method="BH", p.value = 0.05)
de2tags <- rownames(dge_disp2)[as.logical(de2)]
#plotSmear(lrt2, de.tags=de2tags)
plotMD(lrt2, main="MD plot")
abline(h=c(-1, 1), col="blue")
de2_summary <- summary(de2)
de2_summary

#Matrix with Gender and age_category interaction terms
de3 <- decideTestsDGE(lrt3, adjust.method="BH", p.value = 0.05)
de3tags <- rownames(dge_disp3)[as.logical(de3)]
#plotSmear(lrt3, de.tags=de3tags)
plotMD(lrt3, main="MD plot")
abline(h=c(-1, 1), col="blue")
de3_summary <- summary(de3)
de3_summary

```

## GO Analysis

```{r}
# Make function to convert numbers to scientific notation
num.sci <- function(x) {
    format(x, scientific=TRUE, digits = 2)
  }
```


```{r}
# Prepare DEG list for goseq analysis
deg_1_vec <- topTags(lrt1, n = Inf, sort.by = "logFC")$table %>%
    rownames_to_column("gene_id") %>% 
    filter(!is.na(gene_id)) %>% 
    arrange(desc(logFC)) %>% 
    as.data.table %>% 
    (function(.dt) { .dt[, head(.SD,1), by = .(gene_id)] }) %>% 
    mutate(v = as.integer(PValue < 0.05)) %>%
    (function(.dt) { v <- .dt$v; names(v) <- .dt$gene_id; v })

# What does deg_1_vec look like?
head(deg_1_vec)
tail(deg_1_vec)

# Estimate gene-level weights (a null distribution of gene lengths)
pwf_deg_1 <- goseq::nullp(deg_1_vec,"hg19","geneSymbol")

# Run goseq analysis
goseq_results <- goseq::goseq(pwf_deg_1,"hg19","geneSymbol", test.cats = "GO:BP", method = "Wallenius", use_genes_without_cat = TRUE)

# Print top 10 rows of goseq_results
head(goseq_results, 10) %>%
    mutate(over_represented_pvalue = num.sci(over_represented_pvalue)) %>% 
    knitr::kable()

# plot enrichment
goseq_results %>% 
    top_n(10, wt=-over_represented_pvalue) %>% 
    mutate(hitsPerc=numDEInCat*100/numInCat) %>% 
    ggplot(aes(x=hitsPerc, 
               y=term, 
               colour=over_represented_pvalue, 
               size=numDEInCat)) +
        geom_point() +
        expand_limits(x=0) +
        labs(x="Number of Genes", y="GO term", colour="p value", size="Count") +
        scale_colour_viridis(option = "magma")
```


```{r}
# Prepare DEG list for goseq analysis
deg_2_vec <- topTags(lrt2, n = Inf, sort.by = "logFC")$table %>%
    rownames_to_column("gene_id") %>% 
    filter(!is.na(gene_id)) %>% 
    arrange(desc(logFC)) %>% 
    as.data.table %>% 
    (function(.dt) { .dt[, head(.SD,1), by = .(gene_id)] }) %>% 
    mutate(v = as.integer(PValue < 0.05)) %>%
    (function(.dt) { v <- .dt$v; names(v) <- .dt$gene_id; v })

# What does deg_2_vec look like?
head(deg_2_vec)
tail(deg_2_vec)

# Estimate gene-level weights (a null distribution of gene lengths)
pwf_deg_2 <- goseq::nullp(deg_2_vec,"hg19","geneSymbol")

# Run goseq analysis
goseq_results2 <- goseq::goseq(pwf_deg_2,"hg19","geneSymbol", test.cats = "GO:BP", method = "Wallenius", use_genes_without_cat = TRUE)

# Print top 10 rows of goseq_results
head(goseq_results2, 10) %>%
    mutate(over_represented_pvalue = num.sci(over_represented_pvalue)) %>% 
    knitr::kable()

# plot enrichment
goseq_results2 %>% 
    top_n(10, wt=-over_represented_pvalue) %>% 
    mutate(hitsPerc=numDEInCat*100/numInCat) %>% 
    ggplot(aes(x=hitsPerc, 
               y=term, 
               colour=over_represented_pvalue, 
               size=numDEInCat)) +
        geom_point() +
        expand_limits(x=0) +
        labs(x="Number of Genes", y="GO term", colour="p value", size="Count") +
        scale_colour_viridis(option = "magma")
```


```{r}
# Prepare DEG list for goseq analysis
deg_3_vec <- topTags(lrt3, n = Inf, sort.by = "logFC")$table %>%
    rownames_to_column("gene_id") %>% 
    filter(!is.na(gene_id)) %>% 
    arrange(desc(logFC)) %>% 
    as.data.table %>% 
    (function(.dt) { .dt[, head(.SD,1), by = .(gene_id)] }) %>% 
    mutate(v = as.integer(PValue < 0.05)) %>%
    (function(.dt) { v <- .dt$v; names(v) <- .dt$gene_id; v })

# What does deg_3_vec look like?
head(deg_3_vec)
tail(deg_3_vec)

# Estimate gene-level weights (a null distribution of gene lengths)
pwf_deg_3 <- goseq::nullp(deg_3_vec,"hg19","geneSymbol")

# Run goseq analysis
goseq_results3 <- goseq::goseq(pwf_deg_3,"hg19","geneSymbol", test.cats = "GO:BP", method = "Wallenius", use_genes_without_cat = TRUE)

# Print top 10 rows of goseq_results
head(goseq_results3, 10) %>%
    mutate(over_represented_pvalue = num.sci(over_represented_pvalue)) %>% 
    knitr::kable()

# plot enrichment
goseq_results3 %>% 
    top_n(10, wt=-over_represented_pvalue) %>% 
    mutate(hitsPerc=numDEInCat*100/numInCat) %>% 
    ggplot(aes(x=hitsPerc, 
               y=term, 
               colour=over_represented_pvalue, 
               size=numDEInCat)) +
        geom_point() +
        expand_limits(x=0) +
        labs(x="Number of Genes", y="GO term", colour="p value", size="Count") +
        scale_colour_viridis(option = "magma")
```

# Machine learning analysis

## Part 1: Given RNA-seq data, could we predict covid? 

### Data prep 
```{r}
deg3_mod <-  lrt3$table %>% 
                  rownames_to_column("gene")

log2cpm_dat <-  log2cpm %>% 
                as.data.frame() %>% 
                rownames_to_column("gene") %>% 
                filter(gene %in% deg3_mod$gene) %>% 
                pivot_longer(cols = !gene,
                             values_to = "Expression",
                             names_to = "sample_ID")

log2cpm_dat <- dplyr::rename(log2cpm_dat, Sample = sample_ID)

data_ml_temp <- log2cpm_dat %>% 
           left_join(pdata_imputed, 
                     by = "Sample") 

data_ml <- pivot_wider(data_ml_temp, 
                             id_cols = c(Sample, Age_category, Gender, Sars_test), 
                             names_from = gene, 
                             values_from = Expression)

data_ml <- data_ml %>% remove_rownames %>% column_to_rownames(var="Sample")
```



```{r}
# Perform PCA
pca_data_ml <- prcomp(data_ml[,-c(1, 2, 3)], 
                              center = TRUE, 
                              scale. = TRUE)
# See what PCA result looks like
summary(pca_data_ml)

# What are the components of the PCA result
str(pca_data_ml)

# Visualize PCA result by gender
ggbiplot(pca_data_ml, 
         ellipse = TRUE, 
         var.axes = FALSE,
         obs.scale = 1,
         var.scale = 1,
         groups = data_ml$Sars_test) +
  ggtitle("PCA of SARS-Cov2 gene expression by infection status") +
  theme_bw()
  
```

### Data spliting 
```{r}
set.seed(123)
split = sample.split(data_ml$Sars_test, SplitRatio = 0.80) 
data_ml_train = subset(data_ml, split == TRUE) ## Filter to get rows where split is TRUE
data_ml_validate = subset(data_ml, split == FALSE) ## Filter to get rows where split is FALSE
```

## KNN model 
```{r}
train_scale <- scale(data_ml_train[, -])
```

## Naive Bayes model 

## Logistic regression model 

```{r}
## Our dataset has "pos" or 'neg" for the Sars_test status. Such labels are incompatible with logistic regression which requires labels to be 1 or 0
data_ml_train <- data_ml_train %>% 
  mutate(status = as.numeric(case_when(
  Sars_test == "pos" ~ "1",
  Sars_test == "neg" ~ "0"
)))

## Training the classifier
classifier = glm(formula = status ~ .,family = binomial, data = data_ml_train)

## Sanity check! Look at coefficients - only PC3 is significant? 
summary(classifier) 

## Prediction on the validation set
prob_pred = predict(classifier, type = 'response', newdata = test_set[-5]) ## Will return a vector of predicted probabilities of belong to infected (1) vs uninfected (0)

## Since this is a classification problem, we do not want probabilities but instead either 1 or 0.
y_pred = ifelse(prob_pred > 0.5, 1, 0) ## Will round the probabilities to 1 or 0

## Checking how accurate our model is
cm = table(test_set[, 5], y_pred) ## Will return a confusion matrix. We notice that 1 COVID 19 patient was misclassified as healthy and 3 healthy patients were misclassified as diseased.
cm

## will now calculate Accuracy, Sensitivity and Specificity 
con_mat = confusionMatrix(cm, positive = "1")
c(con_mat$overall["Accuracy"], con_mat$byClass["Sensitivity"], con_mat$byClass["Specificity"])

```

